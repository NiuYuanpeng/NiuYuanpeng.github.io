<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-fprintf函数用法-非原创" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/fprintf函数用法-非原创/" class="article-date">
  <time datetime="2015-10-10T03:46:03.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/fprintf函数用法-非原创/">fprintf函数用法(非原创)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、fprintf函数<br>fprintf函数的功能是和printf函数类似，传送格式化输出到一个流中；只不过fprintf函数的读写对象不是 终端 而是 磁盘文件。</p>
<p>函数原型：<br>fprintf（FILE <em> stream, const char </em> format, 输出表列）；</p>
<p>int fprintf(FILE <em>stream, char </em>format[, argument,…]);</p>
<p>fprintf接受一串参数，用format指定的格式串中包含的格式说明符，分别作用在这些参数上，并将格式化数据输出到一个流上。</p>
<p>注意格式 说明符的格数 必须与 参数的格数 相同。（有多少%，后面就有多少参数）如果调用成功，将返回转换的字节数，失败时返回一个负数；</p>
<p>2、fscanf()函数<br>函数原型：int fscanf( FILE <em>stream,const char </em>format [,argument ]… );<br>作用：Read formatted data from a stream.（从流中 读取 格式化的数据）</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:<span class="number">4786</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"iostream.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FALSE <span class="number">0</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span> &gt; g_mapNames;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"> FILE *p = <span class="literal">NULL</span>;</span><br><span class="line">        p = fopen(<span class="string">".//log.txt"</span>,<span class="string">"a+"</span>); <span class="comment">//以a+方式打开一个文件，注意函数fopen的使用；</span></span><br><span class="line"> <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line"> <span class="keyword">char</span> a[<span class="number">6</span>] = <span class="string">"12345"</span>;</span><br><span class="line"><span class="comment">// int b = fprintf(p,"%s/n",a);//fprintf函数如果调用成功，返回转换的字符数；这里是6，相当于sizeof(a)</span></span><br><span class="line"> <span class="keyword">char</span> a1[<span class="number">32</span>] = <span class="string">""</span>;</span><br><span class="line"> <span class="keyword">char</span> a2[<span class="number">32</span>] = <span class="string">""</span>;</span><br><span class="line"> <span class="keyword">int</span> m = <span class="number">2</span>;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">map</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span> &gt; ::iterator iter;<span class="comment">//注意map声明迭代器的时候 要有iterator</span></span><br><span class="line"> <span class="keyword">while</span>( m == <span class="number">2</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  m = <span class="built_in">fscanf</span>(p, <span class="string">"%s/t%s/n"</span>, a1,a2); </span><br><span class="line">  <span class="comment">//往a1,a2里面拷贝字符串,返回的m是拷贝的个数，返回-1是拷贝失败；/t和/n是拷贝的终止符；</span></span><br><span class="line">                                                     <span class="comment">//也就是第一个字符串拷贝的时候以/t结束，第二个以/n结束，分别拷贝到a1 和 a2 中；</span></span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">int</span> a22 = atoi(a2);          <span class="comment">//atoi是把字符串转换成int类型，这里是把a2从字符串转换成int</span></span><br><span class="line">   <span class="comment">//printf("%s/n",a1);</span></span><br><span class="line">   iter = g_mapNames.find(a1);  <span class="comment">//字典的find方法，是查找字典中有没有key，有的话返回智能指针，没有的话指向end();</span></span><br><span class="line">   <span class="keyword">if</span>(iter != g_mapNames.end())</span><br><span class="line">    g_mapNames[a1] += a22;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">    g_mapNames[a1] = a22;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">char</span> mm[<span class="number">128</span>] = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;mm;</span><br><span class="line">  iter = g_mapNames.find(mm);</span><br><span class="line">  <span class="keyword">if</span>( iter != g_mapNames.end())</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s--%d/n"</span>,mm,g_mapNames[mm]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Cannot find your need!/n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//printf("%d/n",g_mapNames.size());</span></span><br><span class="line"> fclose(p);</span><br><span class="line"> p = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/fprintf函数用法-非原创/" data-id="cifkx5ela000p0inojmz4g1pq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fgetc和fputc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/fgetc和fputc/" class="article-date">
  <time datetime="2015-10-10T03:45:46.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/fgetc和fputc/">fgetc和fputc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C语言中文件的读写函数之_fputc、fgetc">C语言中文件的读写函数之 fputc、fgetc</h1><p>首先，我们要知道fputs和fgetc这两个函数是包含在标准库函数中的函数，换句话说，就是封装在标准函数中的两个函数。其中这两个函数都是每次只能输入或者输出一个字符,换而言之,就是不能一下子把所有数据完全输入或者输出.</p>
<h3 id="fgetc函数">fgetc函数</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">fgetc</span>函数的作用就是实现将一个字符读出，其函数的用法形式：</span><br><span class="line"><span class="label">fgetc</span>（ch，<span class="literal">fp</span>）</span><br><span class="line">其中<span class="literal">fp</span>是文件指针，指向要读出的文件，ch是预先定义好的字符型常量，用以接收从<span class="literal">fp</span>所指文件独处的字符</span><br></pre></td></tr></table></figure>
<h3 id="fputc函数">fputc函数</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fputc函数的作用就是实现将一个字符写入文件中，其函数的用法形式：</span><br><span class="line">fputc（<span class="number">ch</span>，wfp）</span><br><span class="line">其中fp是文件指针,指向要写入的文件，<span class="number">ch</span>是预先定义好的字符型常量</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个函数用fclose打开后，一定要判断是否成功打开</p>
<p>另外，传递字符的过程中，要用EOF来判断文件内容是否传递完全，EOF并不是函数中的内容，它只是表示文件读完了，没东西了，就用EOF代替</p>
</blockquote>
<p>接下来就直接来一个实例，我自己编的小程序，功能是实现把一个文件的内容拷贝到另一个文件</p>
<h4 id="fgetc函数和fputc函数实例">fgetc函数和fputc函数实例</h4><p>［C语言］</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">＃include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">＃include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义两个文件指针</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *wfp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个 char 变量,用来打开和接收文件内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">"/Users/qingyun/Desktop/main.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">    wfp = fopen(<span class="string">"homeWork.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查文件是否打开成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == fp)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open the main.txt is error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == wfp)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open the homeWork.txt is error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件并将读取的字符保存到下一个文件</span></span><br><span class="line">    </span><br><span class="line">    ch = fgetc(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ch != EOF )</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    	fputc(ch,wfp);</span><br><span class="line">    	ch = fgetc(fp)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the file main.txt has copied to homeWork.txt\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	fclose（fp）；</span><br><span class="line">	fclose（wfp）；</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/fgetc和fputc/" data-id="cifkx5elc000q0ino427n1z9e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-block-块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/block-块/" class="article-date">
  <time datetime="2015-10-10T03:43:42.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/block-块/">block 块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Objective-C_block代码块">Objective-C  block代码块</h3><ul>
<li>代码块<strong>对象</strong>简称为”代码块”,是对 C语言中函数的扩展.运行在 iOS4.0和 OS X 10.6版本以上</li>
<li>代码块实际上是由 C语言实现的,所以在各种以 C 作为基础的语言内都是有效地,其中包括: Objective-C,C++以及 Objective-C++.</li>
<li>代码块不属于 ANSI 的 C语言标准,但是关于代码块的提议已经提交给了美国标准委员会审议.</li>
<li>代码块本质上是和其他变量相似.不同的是,代码块储存的数据是一个函数体.使用代码块时,可以像调用其他标准函数一样,传入参数,并且得到返回值.</li>
</ul>
<h4 id="函数指针的语法格式">函数指针的语法格式</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="list">(<span class="keyword">*pMyFunction</span>)</span><span class="list">(<span class="keyword">void</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中,按照左右法则,先看括号中的未标示的字符, pMyFunction, 其前面有一个*,说明其实一个指针,再往右看是一个括号,则说明其是一个函数指针,名字是 pMyFunction, 后面的参数为空,前面的返回值亦为空.<br>接下来在 X-Code 中写一个例子来帮助大家理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import &lt;Founction/Foundation.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了一个数据类型 void (*) (void) 给其去一个别名:pMyFunctionRef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pMyFunctionRef)</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个对象</span></span><br><span class="line">pMyFunctionRef pMyFunction;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anotherFunction</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        pMyFunction = myFunction;</span><br><span class="line">        <span class="comment">//通过函数指针来调用函数</span></span><br><span class="line">        pMyFunction();</span><br><span class="line">        </span><br><span class="line">        pMyFunction = anotherFunction;</span><br><span class="line">        pMyFunction();</span><br><span class="line">        <span class="comment">//在创建一个函数指针变量,这个指针变量要存放的函数也是返回类型为空,形参是空</span></span><br><span class="line">        pMyFunctionRef pAnotherFunction;</span><br><span class="line">        pAnotherFunction = myFunction;</span><br><span class="line">        pAnotherFunction();</span><br><span class="line">        <span class="comment">// 在这里,有人会说,你吃饱了撑得,直接调用 anotherFunction 就行了嘛其实不然看下面的两种方法,明显的不同第一种直接调用 anotherFunction 函数,再看第二种,把 anotherFunction 当做参数调用,相当于函数调用函数,这样就强大了</span></span><br><span class="line">        anotherFunction();</span><br><span class="line">        </span><br><span class="line">        callBack(anotherFunction);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的__ fun___ 是 C 中内置的宏,这里的作用的代表这个函数的名字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anotherFunction</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callBack</span><span class="params">(pMyFuntionRef fun)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码块的语法格式">代码块的语法格式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;returntype&gt; (^blockname)(list <span class="keyword">of</span> <span class="built_in">arguments</span>) = ^(<span class="built_in">arguments</span>)&#123;body;&#125;;</span><br></pre></td></tr></table></figure>
<p>举一个简单的例子   </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import &lt;Founction/Foundation.h&gt;</span></span><br><span class="line"><span class="comment">//定义 myBlock函数,形参是 block 块,返回值为空</span></span><br><span class="line"><span class="comment">//定义的 block 块名 block,形参为空,返回值为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBlcok</span>(<span class="params"><span class="keyword">void</span> (^blcok</span>)(<span class="params"></span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> * argv[]</span>)</span>&#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^theBlcok)();</span><br><span class="line">theBlcok = ^&#123;NSLog(<span class="string">@"I am a block"</span>);&#125;;</span><br><span class="line"><span class="comment">//上面的两句可以用一句表示 void (^theBlock)() = ^&#123;NSLog(@"I am a block");&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用块</span></span><br><span class="line">myBlock(theBlock);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myBlcok</span>(<span class="params"><span class="keyword">void</span> (^blcok</span>)(<span class="params"></span>))</span><br><span class="line"></span>&#123;</span><br><span class="line">    blcok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是打印出 I am a block<br>与函数指针对比一下, 其调用方法都几乎是一样的,改变的是*号变成了^,也就是脱字号,其返回值还可以省略,只不过代码块中的是一段代码而已,可以是一个函数.</p>
<p>再来一个例子,输入几个人的名字,实现名字的排序功能,其主代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *students = @[<span class="string">@"ZhangSan"</span>,<span class="string">@"LiSi"</span>,<span class="string">@"WangWu"</span>,<span class="string">@"ZhaoLiu"</span>,<span class="string">@"MaQi"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"unsorted array info:%@"</span>,students);</span><br><span class="line"><span class="comment">//这里使用的NSComparisonResult就是一个 block 块,他是一个枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *sortedStudents = [students </span><br><span class="line">sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span> (<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                 <span class="keyword">return</span> [obj1 compare:obj2];&#125;</span><br><span class="line">            ];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"sorted students info:%@"</span>,sortedStudents);</span><br></pre></td></tr></table></figure>
<p>其结果是:unsorted array info:(<br>    ZhangSan,<br>    LiSi,<br>    WangWu,<br>    ZhaoLiu,<br>    MaQi<br>)<br>2015-06-27 22:03:52.107 BlocksDemo[2990:1834086] sorted students info:(<br>    LiSi,<br>    MaQi,<br>    WangWu,<br>    ZhangSan,<br>    ZhaoLiu<br>)</p>
<h4 id="代码块的变量">代码块的变量</h4><h5 id="关于代码块局部变量">关于代码块局部变量</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef <span class="type">int</span> (^blockType)(<span class="type">void</span>);</span><br><span class="line">        //关于局部变量</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> myInt = <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> anotherInt = <span class="number">200</span>;</span><br><span class="line">//        在<span class="keyword">block</span>内部可以访问和其同一作用域的变量</span><br><span class="line">        blockType blk = ^&#123;<span class="keyword">return</span> myInt * anotherInt;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = blk();</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"the result is %d"</span>,<span class="literal">result</span>);</span><br><span class="line">        </span><br><span class="line">        myInt = <span class="number">10</span>;</span><br><span class="line">        anotherInt = <span class="number">20</span>;</span><br><span class="line">//        在这里根据打印结果来看，其最后的值还是<span class="number">20000</span>,所以说对于<span class="keyword">block</span>来说， 对于局部变量在其定义的时候实际已经赋值。后续是不能修改的</span><br><span class="line">        <span class="literal">result</span> = blk();</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"after modify myInt=10,anotherInt = 20 ther result is %d"</span>,<span class="literal">result</span>);</span><br></pre></td></tr></table></figure>
<h5 id="关于代码块的全局变量">关于代码块的全局变量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个 block 块的类型,类型的名称是: blockType</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(^blockType)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//关于全局变量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> myInt = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> anotherInt = <span class="number">200</span>;</span><br><span class="line">        blockType blk = ^&#123;<span class="keyword">return</span> myInt * anotherInt;&#125;;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"the result is %d"</span>,blk());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        myInt = <span class="number">10</span>;</span><br><span class="line">        anotherInt = <span class="number">30</span>;</span><br><span class="line">        NSLog(@<span class="string">"after modify myInt = 10, and anotherInt = 30 the result is %d"</span>,blk());</span><br></pre></td></tr></table></figure>
<p>代码一开头就是用了 typedef, 声明了一个block块的类型，类型的名称是:blockType   <em>**</em><br>以后如果想声明一个block对象用于返回类型是整型，有一个整型参数的block块的时候， 可以使用blockType类型来声明</p>
<h5 id="关于修改代码块外部变量">关于修改代码块外部变量</h5><p>如果想修改代码块外部的局部变量， 需要在声明这个变量的时候， 用__block来修饰</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       //关于修改代码块外部变量</span><br><span class="line">//        <span class="type">int</span> <span class="literal">result</span> = <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        __block <span class="type">int</span> <span class="literal">result</span> = <span class="number">100</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> (^quare_block)(<span class="type">int</span> number) = ^(<span class="type">int</span> number)&#123;<span class="literal">result</span> =  number * number; <span class="keyword">return</span> <span class="literal">result</span>;&#125;;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"after modify the int result with __block int result:%d"</span>,quare_block(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<p>用<strong>__ block</strong> 修饰的代码块的局部变量是可以修改的,对于 block 来说, result 是一个外部变量,原先的值是100,用<strong>__block</strong> 修饰后,在块的代码中修改 result 的值为20 ,输出的结果: after modify the int result with __block int result:400</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/block-块/" data-id="cifkx5ele000r0ino9uxpso98" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-文件之fread和fwrite" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/文件之fread和fwrite/" class="article-date">
  <time datetime="2015-10-10T03:43:30.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/文件之fread和fwrite/">文件之fread和fwrite</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件操作之fread函数和fwrite函数">文件操作之fread函数和fwrite函数</h1><h4 id="数据块写函数－fwrite">数据块写函数－fwrite</h4><ul>
<li>格式：使用手册man一下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span></span><br><span class="line">     fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nitems,</span><br><span class="line">         FILE *<span class="keyword">restrict</span> stream);</span><br></pre></td></tr></table></figure>
<ul>
<li>含义：从文件指针ptr所指向的内存中读入数据，写入文件stream所指的文件中，写入nitems次数的数据块，每块大小为size字节。</li>
</ul>
<h4 id="数据块写函数－fread">数据块写函数－fread</h4><ul>
<li>格式：使用手册man的结果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span></span><br><span class="line">     fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nitems,</span><br><span class="line">         FILE *<span class="keyword">restrict</span> stream);</span><br></pre></td></tr></table></figure>
<ul>
<li>含义：从文件指针stream所指的文件中读入nitems次数据块，每块的大小为size字节，并保存到文件指针所指向的内存中</li>
</ul>
<blockquote>
<p>注意：fread函数和fwrite函数的返回值是size_t, 返回的是执行写操作的次数，我们在fread函数中可以设置每次读的size，nitems读的次数。因此，可以利用这个特性，在代码中判断一下是否读的正确。<br> 另外，因为我们在函数的使用中，一旦发现文件打不开，或者找不到，又或者数据未写入、未读入等问题，需要用exit（1）来结束程序，所以头文件中必须包含<br> ＃include<stdlib.h>这个头文件</stdlib.h></p>
</blockquote>
<p>接下来是我写的一个小例子，它分为两部分。</p>
<p>第一部分目的：先构造学生信息，然后将学生信息保存到文件里。学生信息包括姓名、年龄、学号.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NAMELEN <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STUNUM  <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.需要构造表示学生信息的类型struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> student</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> name[NAMELEN];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> stuID;</span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.需要构造一个表示学生名字的数组</span></span><br><span class="line"><span class="keyword">char</span> students[STUNUM][NAMELEN] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"zhangsan"</span>,</span><br><span class="line">    <span class="string">"lisi"</span>,</span><br><span class="line">    <span class="string">"wangwu"</span>,</span><br><span class="line">    <span class="string">"zhaoliu"</span>,</span><br><span class="line">    <span class="string">"xiaoqi"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个表示文件的指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打开文件，以写的操作模式</span></span><br><span class="line">    fp = fopen (<span class="string">"/Users/qingyun/Desktop/stu.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">    <span class="comment">//判断文件是否打开成功，如果打开失败，则需要退出程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"open file:stu.txt error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    STU stus[STUNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//如果打开成功，构造学生信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; STUNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//stus[i].name = students[i];</span></span><br><span class="line">        <span class="built_in">strncpy</span>(stus[i].name,students[i],NAMELEN);</span><br><span class="line">        stus[i].age = <span class="number">20</span>+i;</span><br><span class="line">        stus[i].stuID = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将学生信息写入到文件里fwrite</span></span><br><span class="line">    <span class="keyword">size_t</span> nWriteCount = fwrite(stus,<span class="keyword">sizeof</span>(STU),STUNUM,fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目的是确认， 是否正确定写入了所有内容</span></span><br><span class="line">    <span class="keyword">if</span> (nWriteCount != STUNUM )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"write file error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内容是定义了一个二维数组，还有一个结构体，用只输入name，其他内容自动生成的方式。</p>
<p>接下来是第二部分，使用fread读出来，验证下刚才写的内容是否正确</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STULEN <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STUNUM <span class="number">5</span></span></span><br><span class="line"><span class="comment">//构造表示学生类型的数据结构 struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> students</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> name[STULEN];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> stuID;</span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 打开文件指针</span></span><br><span class="line">    fp = fopen(<span class="string">"/Users/qingyun/Desktop/stu.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="comment">// 判断文件是否打开成功,如果失败则退出程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Open file error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明一个缓冲区,用于存放文件的内容</span></span><br><span class="line">    STU stus[STUNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若打开成功,则使用 fread 来读取文件内容</span></span><br><span class="line">    <span class="keyword">int</span> nReadCounts = fread(stus,<span class="keyword">sizeof</span>(STU),STUNUM,fp);</span><br><span class="line">    <span class="comment">// 根据文件函数的返回值来判断文件是否读成功了</span></span><br><span class="line">    <span class="keyword">if</span> (nReadCounts != STUNUM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Read file error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若读取成功的话，打印到屏幕上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; STUNUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the [%d] student info:name is %s,age is %d,stuID is %d\n"</span>,i,stus[i].name,stus[i].age,stus[i].stuID);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 关闭文件指针</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附上显示结果</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">the</span> [<span class="number">0</span>] student info:<span class="property">name</span> <span class="keyword">is</span> zhangsan,age <span class="keyword">is</span> <span class="number">20</span>,stuID <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">the</span> [<span class="number">1</span>] student info:<span class="property">name</span> <span class="keyword">is</span> lisi,age <span class="keyword">is</span> <span class="number">21</span>,stuID <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">the</span> [<span class="number">2</span>] student info:<span class="property">name</span> <span class="keyword">is</span> wangeu,age <span class="keyword">is</span> <span class="number">22</span>,stuID <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">the</span> [<span class="number">3</span>] student info:<span class="property">name</span> <span class="keyword">is</span> zhaoliuxiaoqi,age <span class="keyword">is</span> <span class="number">23</span>,stuID <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">the</span> [<span class="number">4</span>] student info:<span class="property">name</span> <span class="keyword">is</span> ,age <span class="keyword">is</span> <span class="number">24</span>,stuID <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/文件之fread和fwrite/" data-id="cifkx5ek400070inoaq2hvaxd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-文件操作之函数fputs和函数fgets" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/文件操作之函数fputs和函数fgets/" class="article-date">
  <time datetime="2015-10-10T03:43:15.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/文件操作之函数fputs和函数fgets/">文件操作之函数fputs和函数fgets</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文件操作之函数fputs和函数fgets">文件操作之函数fputs和函数fgets</h1><p>####fgets函数</p>
<ul>
<li>最好的学习方法就是查手册，就是在iterm下使用man fgets，fputs以及其他一切不懂的函数或者其他的都可使用手册，就是man一下，你就知道。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *</span><br><span class="line">  <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * <span class="keyword">restrict</span> str, <span class="keyword">int</span> size, FILE * <span class="keyword">restrict</span> stream</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>含义：从文件指针stream所指的文件中读取最多size－1个字符，并储存在字符数组str中，并追加一个’\0’字符。</li>
</ul>
<blockquote>
<p>读取操作遭遇到换行符、文件结束或者错误时停止</p>
</blockquote>
<h4 id="fputs函数">fputs函数</h4><ul>
<li>fputs函数使用前，依然可以使用手册</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line">     <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> s, FILE *<span class="keyword">restrict</span> stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>含义：把字符串s中的内容写入文件指针stream所指向的文件中</li>
</ul>
<blockquote>
<p>fputs不会自动添加‘\n’</p>
</blockquote>
<h4 id="总结">总结</h4><p>其实fputs与fgets在一起配合使用时效果最好，在使用时要注意返回值，fputs的返回值是int，而fgets的返回值是char＊。另外，fgets函数与fgetc函数的区别就在于：fgetc读的是字符，是一个一个读的，而fgets读的是字符串，每次读若干个，与定义有关。fputs函数与fputc函数的区别也是一样，下面是我做的一个小例子，从文件1读内容到文件2，需要手动输入你要进行操作的文件的路径:</p>
<p>［代码］</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SIZE <span class="number">36</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//定义两个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *wfp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//定义字符型数组,用以接受文件</span></span><br><span class="line">    <span class="keyword">char</span> ch[SIZE] = &#123;<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="comment">//判断用户的输入是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"puts error!\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input the right path 命令字  路径1 路径2 \n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>],<span class="string">"r"</span>);</span><br><span class="line">    wfp = fopen(argv[<span class="number">2</span>],<span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == fp || <span class="literal">NULL</span> == wfp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"file open error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行文件操作</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(ch,SIZE,fp) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(ch,wfp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the file copy successful!\n"</span>);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(wfp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/文件操作之函数fputs和函数fgets/" data-id="cifkx5ek200060inooc3t7a37" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-属性之特性-浅谈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/属性之特性-浅谈/" class="article-date">
  <time datetime="2015-10-10T03:43:05.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/属性之特性-浅谈/">属性之特性 浅谈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="特性(_Property)">特性( Property)</h1><ul>
<li>使用特性我们可以避免手工编写繁琐的 setter 和 getter 方法,避免因为这些方法来内存的问题,同       时,也可以节省编写代码的时间</li>
<li><strong>@property</strong> 新的编译器指令,主要功能是为我们自动”生成”,setter 和 getter 方法的声明.(这里需要注意:我们是看不到这些代码的,它们是有编译器自动生成的)</li>
<li><strong>@synthesize</strong> 与@ property 相对应的新的编译器功能.主要是为我们自动生成 setter 和 getter 方法的功能实现.(这里也要注意:我们也看不到相应代码)</li>
</ul>
<p>在这里举一个例子,新建一个 QYTire 类,继承于 NSOhject</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">QYTire :</span> NSObject</span><br><span class="line">&#123;</span><br><span class="line">   <span class="typename">float</span> pressure;<span class="comment">//胎压</span></span><br><span class="line">   <span class="typename">float</span> treadth;<span class="comment">//轮胎花纹情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setPressure:</span>(<span class="typename">float</span>)pressure;</span><br><span class="line">- (<span class="typename">float</span>)pressure;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setTreadth:</span>(<span class="typename">float</span>)treadth;</span><br><span class="line">- (<span class="typename">float</span>)treadth;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>使用@ property 后就变成如下结果</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">QYTire :</span> NSObject</span><br><span class="line">&#123;</span><br><span class="line">   <span class="typename">float</span> pressure;<span class="comment">//胎压</span></span><br><span class="line">   <span class="typename">float</span> treadth;<span class="comment">//轮胎花纹情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@property</span> <span class="typename">float</span> pressure;</span><br><span class="line"><span class="annotation">@property</span> <span class="typename">float</span> treadth;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>而@ synthesize 的用法也是如此,未使用之前,在对应的. m 文件中代码是这样:  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@implementation</span> QYTire</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setPressure:</span>(<span class="typename">float</span>)p</span><br><span class="line">&#123;</span><br><span class="line">    pressure = p;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="typename">float</span>)pressure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pressure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setTreadth:</span>(<span class="typename">float</span>)t</span><br><span class="line">&#123;</span><br><span class="line">    treadth = t;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="typename">float</span>)treadth</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> treadth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>使用了@ synthesize 后可以是这样:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> QYTire</span><br><span class="line"></span><br><span class="line"><span class="variable">@synthesize</span> pressure;</span><br><span class="line"><span class="variable">@synthesize</span> treated;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>而@ property 和@ synthesize 结合使用的结果就是 QYTire.h 文件</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">QYTire </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> float pressure;</span><br><span class="line"><span class="variable">@property</span> float treadth;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>QYTire.m 文件内容如下</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> QYTire</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>这是编译器的新机制,直接省略了@ synthesize, 由编译器自动生成 setter 和 getter 方法.</p>
<h2 id="局限性">局限性</h2><ul>
<li>特性不能用于有参数的 setter 和 getter 方法,如:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setTire</span>:<span class="value">(Tire*) tire atIndex:(int)index</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">Tire</span>*) <span class="rule"><span class="attribute">tireAtIndex</span>:<span class="value">(int)index</span></span>;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/属性之特性-浅谈/" data-id="cifkx5ekc000a0inovd95b8ud" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-属性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/属性/" class="article-date">
  <time datetime="2015-10-10T03:42:50.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/属性/">属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="属性">属性</h1><h3 id="点表达式">点表达式</h3><ul>
<li>使用了@ property 和@ synthesize 后,我们在 setter 和 getter 方法调用的地方可以使用(.)操作来代替函数调用.</li>
<li>点表达式只是调用访问器( setter 和 getter) 的一种快捷方式,并没用其他的功能.   </li>
<li>点的使用语我们 C语言中访问 struct 成员相似, 在 Objective-C 里,如果点出现在 = 左边,表示调用 setter 方法;如果点出现在 = 右边,表示调用getter 方法.</li>
</ul>
<p>建立 类QYTire继承与父类 NSObject,在 QYTire.h 文件中建立方法</p>
<p> 注意: //后是注释,帮助理解</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">QYTire :</span> NSObject</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    float pressure;//胎压</span></span><br><span class="line"><span class="comment">//    float treadth;//轮胎花纹情况</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="annotation">@property</span> <span class="typename">float</span> pressure;<span class="comment">//胎压</span></span><br><span class="line"><span class="annotation">@property</span> <span class="typename">float</span> treadth;<span class="comment">//轮胎花纹情况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)<span class="string">initWithPressure:</span>(<span class="typename">float</span>)pressure;</span><br><span class="line">- (id)<span class="string">initWithTreadth:</span>(<span class="typename">float</span>)treadth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)<span class="string">initWithPressure:</span>(<span class="typename">float</span>)pressure <span class="string">andTreadth:</span>(<span class="typename">float</span>)treadth;</span><br></pre></td></tr></table></figure>
<p>在 QYTire. m 文件中,使用了指定初始化方式,在这里不用关心,只需要关注其成员变量调用时,前面使用了 self. , 例如 self.pressure,  其相当于[self pressure],使用 self 代表本身向自己发送了调用 pressure 的方法,其方法有编译器自动实现,代码我们是看不到的.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QYTire</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure:<span class="number">30.5</span>f andTreadth:<span class="number">20.6</span>f];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithPressure:(<span class="keyword">float</span>)p</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure:p andTreadth:<span class="number">20.6</span>f];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithTreadth:(<span class="keyword">float</span>)t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithPressure:<span class="number">30.5</span>f andTreadth:t];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithPressure:(<span class="keyword">float</span>)p andTreadth:(<span class="keyword">float</span>)t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pressure</span> = p;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.treadth</span> = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特性扩展">特性扩展</h3><p>1.在特性声明的时候,可以添加以下关键字,告诉编译器如何实现 setter 和 getter 方法.   </p>
<ul>
<li>assign //简单赋值，主要用于基本数据类型</li>
<li>copy //创建一个新的对象，新的对象和旧对象是独立的两个对象</li>
<li>retain //将对象计数器加1</li>
<li>readonly //表示只读属性  只会生成getter方法 不会生成setter方法</li>
<li>readwrite //默认值，表示生成setter和getter方法</li>
<li>nonatomic //非原子访问，不加同步 ，多线程并发访问提高性能 （对多线程的保护，防止在未写完，被另一个线程读取，造成数据错误）</li>
</ul>
<h3 id="名称的使用">名称的使用</h3><ul>
<li>主要适用于当实例变量与属性名称需求不同时   </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">synthesize</span> name = appellation</span>;</span><br></pre></td></tr></table></figure>
<p>此时,编译器仍根据属性的特点,合成 setName 和 name 方法,但在是实现的时候,用的是 appellation 实例变量.如下所示:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">setName</span>:<span class="value">(NSString*)name</span><br><span class="line">&#123;</span><br><span class="line">	appellation = name</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/属性/" data-id="cifkx5eke000b0inoewa0oi8h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深拷贝与浅拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/深拷贝与浅拷贝/" class="article-date">
  <time datetime="2015-10-10T03:42:27.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/深拷贝与浅拷贝/">深拷贝与浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3><h5 id="浅拷贝">浅拷贝</h5><ul>
<li>浅拷贝 (shallow copy)     特点:不会复制所引用的对象,其新复制的对象只是一个指针,指向现有的引用对象上.(其实就相当于 Windows 系统下的快捷方式的复制)<br>下面举一个简单地例子来分别下深拷贝与浅拷贝:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个可变的字符串</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *student = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"ZhangSan"</span>];</span><br><span class="line">        <span class="built_in">NSMutableString</span> *anotherStu= [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"LiSi"</span>];</span><br><span class="line"><span class="comment">//     使用两个可变的字符串来创建数组，也就是组里的有两个元素，其元素类型是可变字符串</span></span><br><span class="line">        <span class="built_in">NSArray</span> *students = @[student,anotherStu];</span><br><span class="line"><span class="comment">//     用创建好的数组copy一份赋值给另外一个数组</span></span><br><span class="line">        <span class="built_in">NSArray</span> *copyStu = [students <span class="keyword">copy</span>];</span><br><span class="line"><span class="comment">//     打印原数组和复制得到的数组的内容</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"before moidfy the students:%@ and copyStu:%@"</span>,students,copyStu);</span><br><span class="line"><span class="comment">//     修改复制后得到的数组的第一个元素的值</span></span><br><span class="line">        [copyStu[<span class="number">0</span>] appendString:<span class="string">@"-TeacherZhang"</span>];</span><br><span class="line"><span class="comment">//     打印原数组的值， 查看是否发生了变化</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"after modify copyStu:  the students info:%@"</span>,students);</span><br></pre></td></tr></table></figure>
<p>打印出结果是before moidfy the students:(<br>    ZhangSan,<br>    LiSi<br>) and copyStu:(<br>    ZhangSan,<br>    LiSi<br>)<br>after modify copyStu:  the students info:(<br>    “ZhangSan-TeacherZhang”,<br>    LiSi<br>)<br>这就是浅拷贝,只是拷贝了一个指针,并没有拷贝一个完整的对象.  </p>
<h5 id="深拷贝">深拷贝</h5><ul>
<li>深拷贝 (deep copy)     </li>
</ul>
<p>特点:真正意义上的复制概念.得到的结果是多个,而非只是对象的引用. (对象的完全复制,包括其中的方法)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">//      定义了一个不可变字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *str = <span class="string">@"hello"</span>; </span><br><span class="line">        <span class="comment">//打印出 str 的地址</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"str's address:%p"</span>,str);</span><br><span class="line">        <span class="comment">//通过mutableCopy协议可以将不可变的字符串转化为可变字符串</span></span><br><span class="line">        <span class="built_in">NSMutableString</span> *anotherStr = [str mutableCopy];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"anotherStr's address:%p"</span>,anotherStr);</span><br><span class="line">        </span><br><span class="line">        [anotherStr appendString:<span class="string">@"qingyun"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"anotherString:%@"</span>,anotherStr);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSMutableString</span> *mStr = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"HELLO"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"mStr's address:%p"</span>,mStr);</span><br><span class="line"><span class="comment">//        通过copy协议可以将可变字符串转换为不可变字符串</span></span><br><span class="line">        <span class="built_in">NSMutableString</span> *anotherMStr = [mStr <span class="keyword">copy</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"anotherMStr's address:%p"</span>,anotherMStr);</span><br><span class="line">        [anotherMStr appendString:<span class="string">@"-QINGYUN"</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义对象的拷贝">自定义对象的拷贝</h5><p>实现自定义对象的拷贝的前提是必须要实现协议,否则,自定义对象调用 copy 对象的时候会发生崩溃的现象.<br>实例来说明这个问题,创建一个 QYCar 的类继承自 NSObject, 且遵从 NSCopying 协议,在 main.m 中实现自定义对象的 copy</p>
<p>在 QYCar 的头文件中,代码如下:   </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QYCar</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)<span class="built_in">NSInteger</span> year;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 QYCar.m 中的代码如下:   </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"QYCar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QYCar</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开箱即用的初始化方式</span></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.name</span> = <span class="string">@"BWM"</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.year</span> = <span class="number">2013</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"name:%@,year:%ld"</span>, <span class="keyword">self</span><span class="variable">.name</span>,<span class="keyword">self</span><span class="variable">.year</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    QYCar *carCopy;</span><br><span class="line">    </span><br><span class="line">    carCopy = [QYCar allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    carCopy<span class="variable">.name</span> = <span class="keyword">self</span><span class="variable">.name</span>;</span><br><span class="line">    carCopy<span class="variable">.year</span> = <span class="keyword">self</span><span class="variable">.year</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> carCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 main.m 中建立一个对象 car, 并调用开箱即用的初始化方式,然后再新建一个对象 carCopy, 并把 car 的内容 copy 给 carCopy, 为了显示我们成功拷贝了 car, 更改 carCopy 的 name 属性,并打印出来,显示下我们这是深拷贝.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        QYCar *car = [[QYCar alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"car:%@"</span>,car);</span><br><span class="line">        </span><br><span class="line">        QYCar *carCopy = [car <span class="keyword">copy</span>];</span><br><span class="line">        carCopy<span class="variable">.name</span> = <span class="string">@"HeNanCar"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"carCopy:%@"</span>,carCopy);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"car again : %@"</span>,car);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果是:<br>2015-07-01 21:06:43.302 SelfWithCopy[2631:2055248] car:name:BWM,year:2013<br>2015-07-01 21:06:43.303 SelfWithCopy[2631:2055248] carCopy:name:HeNanCar,year:2013<br>2015-07-01 21:06:43.303 SelfWithCopy[2631:2055248] car again : name:BWM,year:2013</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/深拷贝与浅拷贝/" data-id="cifkx5ek000050inoj2bc1x4e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-内存管理之-arc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/内存管理之-arc/" class="article-date">
  <time datetime="2015-10-10T03:42:16.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/内存管理之-arc/">内存管理之_arc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="内存管理之_ARC_和_自动释放池">内存管理之 ARC 和 自动释放池</h2><h4 id="一、ARC_中的变量所有权修饰符">一、ARC 中的变量所有权修饰符</h4><p>变量修饰符,主要用来标识对象的生命周期.在手动内存管理方式中没有这些概念.<br>ARC 环境下变量所有权修饰符主要有以下几个: </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span>   </span><br><span class="line">__<span class="keyword">weak</span></span><br><span class="line">__unsa_unretained</span><br><span class="line">__autoreleasing</span><br></pre></td></tr></table></figure>
<p>详细说明:<br>(1) 变量默认值都是<strong>__ strong</strong> 修饰<br>只要强引用存在,对象就不能释放.当超过了对象的作用域以及没有强引用时,对象会自动销毁.<br><strong>__strong</strong> 属性基本上能适应 ARC 环境下的所有情况.如果不写的话,默认为<strong>__ strong</strong> 属性.<br>(2) <strong>__weak</strong> 不持有对象,只是简单地引用而已.<br>也就是说,<strong>__weak</strong>不会影响对象的销毁，只要<strong>__weak</strong> 修饰的对象没有强引用时,就会自动销毁,这时候<strong>__ weak</strong> 变量会自动设置成 nil.<br>下面是一个例子</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *__<span class="keyword">weak</span> str = [][<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"I am studying"</span>];</span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"str : %@"</span>,str);</span><br></pre></td></tr></table></figure>
<p>因为 str 这个对象是弱引用,编译器会提示,这是一个弱引用,输出的结果: str:null</p>
<p>在你打开ARC时，你是不能使用retainrelease autorelease 操作的，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了，但是你需要在对象属性上使用weak 和strong, 其中strong就相当于retain属性，而weak相当于assign，基础类型还是使用assign。</p>
<h4 id="二、自动释放池">二、自动释放池</h4><ul>
<li>自动释放池是一个存放实体的集合,这些实体可能是对象,这些对象能够被自动释放.</li>
<li>(id)autorelease;// 是 NSObject提供的方法,此方法在某一个预定的时候,想对象发送 release 消息,返回值是接收消息的对象.实际上当给一个对象发送 autorelease 消息的时候,就是将这个对象添加到自动释放池( NSAutoreleasePool) 中,当自动释放池被销毁时,会向该池中的所有对象发送 release 消息</li>
</ul>
<h6 id="临时对象和拥有对象">临时对象和拥有对象</h6><p>当使用如：arrayWithCapacity这样的方法获取临时对象的时候，你不必考虑内存释放问题。<br>[NSColor blueColor]; 单例对象，永远不会被销毁，但是你也不必考虑它的内存问题。<br>如果在你自定义的类中依赖其它对象时，你需要重写dealloc方法，并且在这个方法中释放依赖的对象<br>如果在设计的循环体中会占用较多的内存空间，建议手动创建自动释放池。如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];   </span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;   		</span><br><span class="line"><span class="keyword">id</span> object = [someArray objectAtIndex:i];		</span><br><span class="line"><span class="built_in">NSString</span> *desc = [object description];		</span><br><span class="line"><span class="comment">// and do something with te descripton</span></span><br><span class="line"> 		<span class="keyword">if</span> ( i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line"> 			[pool release];      		     </span><br><span class="line"> 			pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"> 		&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h6 id="APC_的本质">APC 的本质</h6><ul>
<li>ARC 本质上是由编译器在编译阶段,在合适的地方插入 retain 和 release 方法.</li>
<li>ARC 是编译时的特性.</li>
</ul>
<h6 id="关于_ROP_和_non-ROP">关于 ROP 和 non-ROP</h6><p>所有权归属问题</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *theString = <span class="string">@"Hello,Henan"</span>;   </span><br><span class="line"><span class="built_in">CFStringRef</span> cfString = (<span class="built_in">CFStringRef</span>)theString</span><br><span class="line"></span><br><span class="line"><span class="comment">// __bridge  </span></span><br><span class="line"></span><br><span class="line">   cfString = (__bridge <span class="built_in">CFStringRef</span>)theString <span class="comment">//指针的所有权不变,所以是 theString</span></span><br><span class="line"><span class="comment">// __bridge_retained</span></span><br><span class="line">   cfString = (__bridge_retained <span class="built_in">CFStringRef</span>)theString<span class="comment">// 指针的所有权对象是 cfString</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  __bridge_transfer</span></span><br><span class="line"></span><br><span class="line">  cfString = (__bridge_transfer <span class="built_in">CFStringRef</span>)theString<span class="comment">// 指针的所有权属于 theString</span></span><br></pre></td></tr></table></figure>
<h5 id="使用_ARC_的一些强制规定">使用 ARC 的一些强制规定</h5><ol>
<li>不能直接调用 dealloc 方法,不能调用 retain,release,autorelease,retainCount 方法,包括@ selector(retain) 的方法也不行.</li>
<li>如果你需要管理资源而不是释放实例变量,你应该事先 dealloc 方法.不能再 dealloc 方法里面去调[ super dealloc] 方法,在 ARC下父类的 dealloc 同样由编译器来自动完成.</li>
<li>Core Foundation 类型的对象仍然可以用 CFRetain,CFRealese 这些方法.</li>
<li>不能在使用 NSAllocateObject和 NSDeallocateObject 对象.</li>
<li>不能在 C 结构中使用对象指针,如果有类似功能,可以创建一个 Objective-C 类来管理这些对象</li>
<li>在 id和 void * 之间没有简便的转换方法,同样在Objective-C 和 Core Foundation 类型之间的转换都需要使用编译器指定的转换函数.</li>
<li>不能再使用 NSAutoreleasePool 对象, ARC 提供了@ autoreleasepool 块来替代它,这样更加有效率.</li>
<li>不能使用内存储存区(不能再使用 NSZone)</li>
<li>不能以 new 为开头给一个属性命名.</li>
<li>声明 outlet 时一般使用 weak, 除了对 StoryBoard 这样的 nib 中间的顶层对象要用 strong.</li>
<li>weak 相当于老版本的 assign,strong 相当于 retain.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/内存管理之-arc/" data-id="cifkx5ekj000e0inodhm4th19" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/10/内存管理/" class="article-date">
  <time datetime="2015-10-10T03:42:07.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/内存管理/">内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="内存管理">内存管理</h2><h4 id="内存的管理机制:引用计数">内存的管理机制:引用计数</h4><p>每个对象都有一个与之相关联的整数,称之为这个对象的引用计数器.当某段代码需要访问一个对象时,这段代码需要将对象的引用计数器加1,表示我要拥有或者访问这个对象.当这段代码结束对象访问时,需要将对象的引用计数器减1,表示它将不再拥有或访问这个对象.当此对象的保留计数器为0时,表示不再有代码需要访问此对象.因此对象的生命周期将结束,其占用的内存被系统回收.(简而言之:当一个对象被分配内存之后,他的引用计数器是1,当需要使用时,需要保留,不用的时候,减一,当引用计数为零时,需要销毁,销毁时,需要调用 dealloc 方法,完成与之相关的对象的销毁)</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">－ alloc、new、copy（copy生成接收对象的一个副本）//使用这三个方法创建对象时,对象的引用计数器为1</span><br><span class="line">-<span class="ruby"> (id) retain;<span class="regexp">//</span> 给对象发送 <span class="keyword">return</span> 消息后,对象的引用计数器加<span class="number">1</span></span><br><span class="line"></span>-<span class="ruby"> (void)release;<span class="regexp">//</span> 向对象发送 release 消息后,对象的引用计数器减<span class="number">1</span></span><br><span class="line"></span>-<span class="ruby"> (void) dealloc;<span class="regexp">//</span> 当一个对象的引用计数器变为<span class="number">0</span>而即将被销毁时 ,<span class="constant">Objective</span>-<span class="constant">C</span> 自动想对象发送一条 dealloc 消息,我们通常都会在自己的对象中重写 dealloc 方法</span><br><span class="line"></span>-<span class="ruby"> (unsigned) retainCount;<span class="regexp">//</span> 获取当前对象的引用计数器的值</span></span><br></pre></td></tr></table></figure>
<p>接下来演示一个例子,来帮助大家理解引用计数器的机制<br>首先建立一个 QYStudent 的类继承与 NSObject 类,然后只需要在 QYStudent.m 文件中实现输出一句话和引用计数器为0时的delloc 的方法,并且也输出一句话代表要销毁这个对象了.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"QYStudent.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QYStudent</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"hello-student"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我毕业了"</span>);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>注意:这里的[ super delloc] 是因为手动管理内存时,当对象所对应的引用计数器为0时,需要销毁此对象来释放内存,此时,应首先从超类中开始释放内存,如果是子类中已释放了对象,而超类中还保存有此对象的内存,会造成内存的泄露.</p>
<p>在 main 中实现一下 retain 后的结果 </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"QYStudent.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//实例化一个QYStudent对象</span></span><br><span class="line">    QYStudent *stu = [QYStudent new];</span><br><span class="line"><span class="comment">//    查看一下他的引用计数器值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[stu retainCount]);</span><br><span class="line"><span class="comment">//    对引用计数器实现加1操作</span></span><br><span class="line">    [stu retain];</span><br><span class="line"><span class="comment">//    再查看引用计数器的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[stu retainCount]);</span><br><span class="line"><span class="comment">//    再对引用计数器实现加1操作。</span></span><br><span class="line">    [stu retain];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[stu retainCount]);</span><br><span class="line"><span class="comment">//    对引用计数器实现减1操作</span></span><br><span class="line">    [stu release];</span><br><span class="line"><span class="comment">//    查看对象的引用计数器</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[stu retainCount]);</span><br><span class="line"><span class="comment">//    再减1</span></span><br><span class="line">    [stu release];<span class="comment">//1</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[stu retainCount]);</span><br><span class="line"><span class="comment">//    再减1，直到减为0</span></span><br><span class="line">    [stu release];<span class="comment">//0</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,[stu retainCount]);</span><br><span class="line"><span class="comment">//   当对象的引用计数器变为0的时候， Objective-C的机制会向对象发送dealloc消息查看对象的dealloc方法是否被调用了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出的结果是<br>2015-06-28 10:00:11.429 MemoryMgrDemo[651:193650] 1<br>2015-06-28 10:00:11.430 MemoryMgrDemo[651:193650] 2<br>2015-06-28 10:00:11.430 MemoryMgrDemo[651:193650] 3<br>2015-06-28 10:00:11.430 MemoryMgrDemo[651:193650] 2<br>2015-06-28 10:00:11.431 MemoryMgrDemo[651:193650] 1<br>2015-06-28 10:00:17.864 MemoryMgrDemo[651:193650] 我毕业了<br>2015-06-28 10:00:32.513 MemoryMgrDemo[651:193650] 1<br>最后一个值为什么为1,按照我们的本意,当调用过[ super delloc] 以后, stu 的引用计数器值应该为0,释放掉了相应的内存啊.其实这里是编译器的延迟,把已释放掉的当做未释放掉才会出现这个问题</p>
<h4 id="对象所有权">对象所有权</h4><ul>
<li>内存管理之所以复杂,感觉理解起来很难,都是因为对象的所有权问题引起的.   </li>
<li>那么什么是对象所有权<br>如果一个对象具有指向其它对象的实例变量,则称该对象拥有这些对象<br>如果一个函数创建了一个对象,则称该函数拥有它创建的对象   </li>
<li>下面是一段代码,根据代码分析下那个实体拥有对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">		Car *car = [[Car alloc] init];</span><br><span class="line">		Engine *engine = [Engine <span class="keyword">new</span>];</span><br><span class="line">		[car setEngine:engine];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象engine时属于哪个实体呢?<br>首先由于 Car 类的对象在使用 engine, 所以不可能是 main 拥有 engine, 其次由于 main 创建了对象 engine, 后面还要用所以也不可能是 Car 类拥有 engine,那如何解决呢?<br>解决方法:让 Car 类保留 engine, 也就是将 engine 的引用计数器加1,变为2.这是因为 main 和 Car 两个实体都拥有 engine 对象. Car类应该在 setEngine: 方法中保留 engine 对象.而 main 函数应该释放 engine 对象,然后当 Car 对象完成其任务时再释放 engine 对象(在 dealloc), 最后 engine 对象占用的内存被回收.那么重点来了,如何设置 setEngine 的方法.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">setEngine:</span>(QYEngine *)eng&#123;</span><br><span class="line"></span><br><span class="line">    [eng retain];</span><br><span class="line">    engine = eng;</span><br><span class="line">   </span><br><span class="line">&#125;<span class="comment">//setEngine</span></span><br></pre></td></tr></table></figure>
<p>在其 main 函数中这样写   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    QYCar *car = [QYCar <span class="keyword">new</span>];</span><br><span class="line">    </span><br><span class="line">    QYEngine *engine = [QYEngine <span class="keyword">new</span>];<span class="comment">//计数器为1</span></span><br><span class="line">    </span><br><span class="line">    [car setEngine:engine];</span><br><span class="line">    <span class="comment">//此时调用 setEngine 方法, engine 的计数器变成2了</span></span><br><span class="line">    [engine release];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main 函数中使用 engine</span></span><br><span class="line">     QYEngine *anotherEngine = [car engine];</span><br><span class="line">    </span><br><span class="line">    [car setEngine:anotherEngine];</span><br><span class="line">	[car release]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码分析可知,实例 engine 对象时,其计数器为1,就是指针 engine 指向内存中为它分配的一块空间,接下来向 setEngine 发送消息,计数器的值变为2,然后 release, 值又变成1,这样就出问题了,相当于 engine 对象没有释放掉,会造成内存的泄露.<br>下面接着修改 setEngine 方法  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">setEngine:</span>(QYEngine *)eng&#123;</span><br><span class="line">    </span><br><span class="line">    [eng release];</span><br><span class="line">   	 engine = eng;</span><br><span class="line">&#125;<span class="comment">//setEngine</span></span><br></pre></td></tr></table></figure>
<p>这样该表面是可以避免内存最后不被泄露,可以解决上面的问题,某些 Objective-C 的教材上也是这样认为的,其实不然.我们来分析下,同样的实例化 engine 对象,计数器为1,car 向发送 setEngine发送消息,来到了 setEngine 方法中,实现的不是计数器加1,而是 release, 即减1,计数器变为了0,直接接就释放了 engine 对象的内存,好了,程序结束了. engine 对象在 main 函数中还未使用,就直接被释放掉了.<br>下面是比较好的解决方案   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    QYCar *car = [QYCar <span class="keyword">new</span>];</span><br><span class="line">    </span><br><span class="line">    QYEngine *engine = [QYEngine <span class="keyword">new</span>];<span class="comment">//计数器为1</span></span><br><span class="line">    </span><br><span class="line">    [car setEngine:engine];</span><br><span class="line">    <span class="comment">//此时调用 setEngine 方法, engine 的计数器变成2了</span></span><br><span class="line">    [engine release];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main 函数中使用 engine</span></span><br><span class="line">     QYEngine *anotherEngine = [car engine];</span><br><span class="line">    </span><br><span class="line">    [car setEngine:anotherEngine];</span><br><span class="line">	[car release]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setEngine:(QYEngine *)eng&#123;</span><br><span class="line"></span><br><span class="line">    [eng retain]<span class="comment">;</span></span><br><span class="line">    [engine release]<span class="comment">;</span></span><br><span class="line">    engine = eng<span class="comment">;</span></span><br><span class="line">&#125;//setEngine</span><br></pre></td></tr></table></figure>
<p>其实涉及到内存方面的内容,最好的方法就是画示意图,这样才能明确表达内存的申请以及释放过程</p>
<h5 id="内存管理总结">内存管理总结</h5><ul>
<li>“如果我使用了new , alloc 或者copy方法获得一个对象，则我必须释放或自释放该对象。”</li>
<li>如果你对对象调用了retain消息，那么你必须负责释放(release)这个对象，保证retain和release的使用次数相等。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/10/内存管理/" data-id="cifkx5ekl000f0ino6b0ga4q9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/10/常用快捷操作/">常用快捷操作</a>
          </li>
        
          <li>
            <a href="/2015/10/10/uiview常用属性和方法/">uiview常用属性和方法</a>
          </li>
        
          <li>
            <a href="/2015/10/10/KVO-概述及用法/">KVO 概述及用法</a>
          </li>
        
          <li>
            <a href="/2015/10/10/KVC-概述/">KVC 概述</a>
          </li>
        
          <li>
            <a href="/2015/10/10/KVC-补充及实例/">KVC 补充及实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>